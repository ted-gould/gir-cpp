#!/usr/bin/python3

import sys
from gi.repository import Zeitgeist as importedgir
import gi

class Typeinfo:
	def __init__(self, cstr, cppstr, c2cpp, cpp2c, cfree = ''):
		self._cstr = cstr
		self._cppstr = cppstr
		self._cpp2c = cpp2c
		self._c2cpp = c2cpp
		self._cfree = cfree
	def cstr (self):
		return self._cstr
	def cppstr (self):
		return self._cppstr
	def cpp2c (self, varname):
		return self._cpp2c % (varname)
	def c2cpp (self, varname):
		return self._c2cpp % (varname)
	def cfree (self, varname):
		if self._cfree == '':
			return ''
		return self._cfree % (varname)
	def marker (self):
		return self._marker

class TypeUnknown(Typeinfo):
	def __init__(self):
		self._cstr = 'unknown'

class TypeBool(Typeinfo):
	def __init__(self):
		self._cstr = 'gboolean'
		self._cppstr = 'bool'
		self._c2cpp = '(%s == TRUE ? true : false)'
		self._cpp2c = '(%s ? TRUE : FALSE)'
		self._cfree = ''

class TypeInt(Typeinfo):
	def __init__(self):
		self._cstr = 'gint32'
		self._cppstr = 'int'
		self._c2cpp = '%s'
		self._cpp2c = '%s'
		self._cfree = ''
		self._marker = '0'

class TypeInt64(Typeinfo):
	def __init__(self):
		self._cstr = 'gint64'
		self._cppstr = 'long'
		self._c2cpp = '%s'
		self._cpp2c = '%s'
		self._cfree = ''
		self._marker = '0'

class TypeString(Typeinfo):
	def __init__(self):
		self._cstr = 'gchar *'
		self._cppstr = 'std::string'
		self._c2cpp = 'std::string(%s)'
		self._cpp2c = 'g_strdup(%s.get_cstr())'
		self._cfree = 'g_free(%s)'
		self._marker = 'NULL'

class TypeArray(Typeinfo):
	def __init__(self, insidetype):
		self._insidetype = insidetype
	def cstr (self):
		cstr = self._insidetype.cstr()
		cstr += '*'
		return cstr
	def cppstr (self):
		return 'std::vector<%s>' % (self._insidetype.cppstr())
	def c2cpp (self, varname):
		cbuilder = ''
		cbuilder += '[](%s input) => %s {' % (self.cstr(), self.cppstr())
		cbuilder += '%s retval();' % self.cppstr()
		cbuilder += 'int i = 0; '
		cbuilder += 'for (i = 0; input[i] != %s; i++) {' % (self._insidetype.marker())
		cbuilder += '%s cppitem = %s;' % (self._insidetype.cppstr(), self._insidetype.c2cpp('input[i]'))
		cbuilder += 'retval.append(cppitem);'
		cbuilder += '}'
		cbuilder += 'return retval;'
		cbuilder += '}(%s)' % varname
		return cbuilder
	def cpp2c (self, varname):
		cbuilder = ''
		cbuilder += '[](%s input) => %s {' % (self.cstr(), self.cppstr())
		cbuilder += 'GArray * retarray = g_array_new(TRUE, TRUE, sizeof(%s));' % (self._insidetype.cstr())
		cbuilder += 'std::for_each(input.begin(), input.end(), [retarray](%s item) {'
		cbuilder += '%s item_cval = %s;' % (self._insidetype.cstr(), self._insidetype.cpp2c('item'))
		cbuilder += 'g_array_append_val(retarray, item_cval);'
		cbuilder += '});'
		cbuilder += 'return (%s)g_array_free(retarray, FALSE);' % (self._insidetype.cstr())
		cbuilder += '}(%s)' % varname
		return cbuilder
	def cfree (self, varname):
		cbuilder = ''
		cbuilder += '[](%s input) {' % (self.cstr())
		cbuilder += 'int i = 0; '
		cbuilder += 'for (i = 0; input[i] != %s; i++) {' % (self._insidetype.marker())
		cbuilder += self._insidetype.cfree('input[i]')
		cbuilder += '}'
		cbuilder += 'g_free(input);'
		cbuilder += '}(%s)' % varname
		return cbuilder

def typeParse (typeinfo):
	if typeinfo.get_tag_as_string() == 'gboolean':
		return TypeBool()
	elif typeinfo.get_tag_as_string() == 'gint32':
		return TypeInt()
	elif typeinfo.get_tag_as_string() == 'gint64':
		return TypeInt64()
	elif typeinfo.get_tag_as_string() == 'utf8':
		return TypeString()
	elif typeinfo.get_tag_as_string() == 'array':
		internaltype = typeParse(typeinfo.get_param_type(0))
		if internaltype.cstr() == 'unknown':
			return TypeUnknown()
		return TypeArray(internaltype)
	else:
		print("Unknown: %s" % (typeinfo.get_tag_as_string()))
		return TypeUnknown()

def functionParse (func):
	returntype = typeParse(func.get_return_type())
	if returntype.cstr() == 'unknown':
		return ''
	functiondef = ''
	if not func.skip_return():
		functiondef += returntype.cppstr()
	else:
		functiondef += 'void'
	functiondef += ' '
	functiondef += func.get_name()
	functiondef += ' ( '
	for arg in func.get_arguments():
		argtype = typeParse (arg.get_type())
		if argtype.cstr() == 'unknown':
			return ''
		functiondef += typeParse(arg.get_type()).cppstr()
		functiondef += ' '
		functiondef += arg.get_name()
		functiondef += ', '
	functiondef += ' ) {\n'

	for arg in func.get_arguments():
		argtype = typeParse (arg.get_type())
		functiondef += argtype.cstr();
		functiondef += ' %s_ctype = ' % (arg.get_name())
		functiondef += argtype.cpp2c(arg.get_name())
		functiondef += ';\n'

	functiondef += '\n'

	if not func.skip_return():
		functiondef += returntype.cstr();
		functiondef += ' retval_ctype = ';

	functiondef += '%s (' % (func.get_symbol())

	if func.is_method():
		functiondef += 'this, '

	for arg in func.get_arguments():
		functiondef += '%s_ctype, ' % (arg.get_name())

	functiondef += ');\n'

	if not func.skip_return():
		functiondef += returntype.cppstr()
		functiondef += ' retval = '
		functiondef += returntype.c2cpp('retval_ctype')
		functiondef += ';\n'
		cfree = returntype.cfree('retval_ctype')
		if cfree != '':
			functiondef += '%s;\n' % (cfree)

	functiondef += '\n'

	for arg in func.get_arguments():
		argtype = typeParse (arg.get_type())
		cfree = argtype.cfree('%s_ctype' % (arg.get_name()))
		if cfree != '':
			functiondef += '%s;\n' % (cfree)

	functiondef += '\n'
	
	if not func.skip_return():
		functiondef += 'return retval;\n'
	else:
		functiondef += 'return;\n'

	functiondef += '}\n\n'
	return functiondef 

def objectParse (obj):
	info = obj.__info__
	cppout = '';
	cppout += 'class %s {\n' % (obj.__name__)
	cppout += 'private:\n'
	cppout += 'std::shared_ptr<%s> internalObjectPtr;\n' % (info.get_type_name())
	cppout += 'public:\n'
	cppout += '/* constructors */\n'
	cppout += '%s (%s * inobj) {\n' % (obj.__name__, info.get_type_name())
	cppout += 'internalObjectPtr = std::make_shared<%s>(g_object_ref_sink(inobj), [](%s * deadobj){ g_clear_object(&deadobj); });' % (info.get_type_name(), info.get_type_name())
	cppout += '}\n'
	cppout += '%s (std::shared_ptr<%s> inobj) {\n' % (obj.__name__, info.get_type_name())
	cppout += 'internalObjectPtr = inobj;\n'
	cppout += '}\n'

	cppout += '\n/* methods */\n'
	for method in info.get_methods():
		cppout += functionParse(method)

	cppout += '\n/* casting */\n'
	cppout += 'operator %s * () {\n' % (info.get_type_name())
	cppout += 'return internalObjPtr.get();\n'
	cppout += '}\n'
	cppout += 'operator std::shared_ptr<%s> () {\n' % (info.get_type_name())
	cppout += 'return std::copy(internalObjectPtr);\n'
	cppout += '}\n'
	cppout += 'operator GObject * () {\n'
	cppout += 'return G_OBJECT(internalObjPtr.get());\n'
	cppout += '}\n'

	cppout += '}\n\n'
	return cppout

def namespaceParse (obj):
	cppout = ''

	for item in obj.__dir__():
		if item.startswith('_'):
			continue
		if str(obj.__getattr__(item).__class__) == "<class 'gi.FunctionInfo'>":
			cppout += functionParse(obj.__getattr__(item))
		elif str(obj.__getattr__(item).__class__) == "<class 'gi.types.GObjectMeta'>":
			cppout += objectParse(obj.__getattr__(item))

	return cppout

if __name__ == '__main__':
	cpp = 'namespace GirCpp::%s {\n' % (importedgir._namespace)
	cpp += namespaceParse(importedgir);
	cpp += '}\n'
	print(cpp);
