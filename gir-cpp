#!/usr/bin/python3

import sys
from gi.repository import UbuntuAppLaunch as importedgir
import gi

class Typeinfo:
	def __init__(self, cstr, cppstr, c2cpp, cpp2c, cfree = ''):
		self._cstr = cstr
		self._cppstr = cppstr
		self._cpp2c = cpp2c
		self._c2cpp = c2cpp
		self._cfree = cfree
	def cstr (self):
		return self._cstr
	def cppstr (self):
		return self._cppstr
	def cpp2c (self, varname):
		return self._cpp2c % (varname)
	def c2cpp (self, varname):
		return self._c2cpp % (varname)
	def cfree (self, varname):
		if self._cfree == '':
			return ''
		return self._cfree % (varname)

class TypeUnknown(Typeinfo):
	def __init__(self):
		self._cstr = 'unknown'

class TypeBool(Typeinfo):
	def __init__(self):
		self._cstr = 'gboolean'
		self._cppstr = 'bool'
		self._c2cpp = '(%s == TRUE ? true : false)'
		self._cpp2c = '(%s ? TRUE : FALSE)'
		self._cfree = ''

class TypeInt(Typeinfo):
	def __init__(self):
		self._cstr = 'gint32'
		self._cppstr = 'int'
		self._c2cpp = '%s'
		self._cpp2c = '%s'
		self._cfree = ''

class TypeString(Typeinfo):
	def __init__(self):
		self._cstr = 'gchar *'
		self._cppstr = 'std::string'
		self._c2cpp = 'std::string(%s)'
		self._cpp2c = '%s.get_cstr()'
		self._cfree = 'g_free(%s)'

class TypeArray(Typeinfo):
	def __init__(self, insidetype):
		self._insidetype = insidetype
	def cstr (self):
		cstr = self._insidetype.cstr()
		cstr += '*'
		return cstr
	def cppstr (self):
		return 'std::vector<%s>' % (self._insidetype.cppstr())
	def c2cpp (self, varname):
		return ''
	def cpp2c (self, varname):
		return ''
	def cfree (self, varname):
		return ''

def typeParse (typeinfo):
	if typeinfo.get_tag_as_string() == 'gboolean':
		return TypeBool()
	elif typeinfo.get_tag_as_string() == 'gint32':
		return TypeInt()
	elif typeinfo.get_tag_as_string() == 'utf8':
		return TypeString()
	elif typeinfo.get_tag_as_string() == 'array':
		return TypeArray(typeParse(typeinfo.get_param_type(0)))
	else:
		return TypeUnknown()

def functionParse (func):
	returntype = typeParse(func.get_return_type())
	if returntype.cstr() == 'unknown':
		return ''
	functiondef = ''
	if not func.skip_return():
		functiondef += returntype.cppstr()
	else:
		functiondef += 'void'
	functiondef += ' '
	functiondef += func.get_name()
	functiondef += ' ( '
	for arg in func.get_arguments():
		argtype = typeParse (arg.get_type())
		if argtype.cstr() == 'unknown':
			return ''
		functiondef += typeParse(arg.get_type()).cppstr()
		functiondef += ' '
		functiondef += arg.get_name()
		functiondef += ', '
	functiondef += ' ) {\n'

	for arg in func.get_arguments():
		argtype = typeParse (arg.get_type())
		functiondef += argtype.cstr();
		functiondef += ' %s_ctype = ' % (arg.get_name())
		functiondef += argtype.cpp2c(arg.get_name())
		functiondef += ';\n'

	if not func.skip_return():
		functiondef += returntype.cstr();
		functiondef += ' retval_ctype = ';

	functiondef += '%s (' % (func.get_symbol())

	for arg in func.get_arguments():
		functiondef += '%s_ctype, ' % (arg.get_name())

	functiondef += ');\n'

	if not func.skip_return():
		functiondef += returntype.cppstr()
		functiondef += ' retval = '
		functiondef += returntype.c2cpp('retval_ctype')
		functiondef += ';\n'
		cfree = returntype.cfree('retval_ctype')
		if cfree != '':
			functiondef += '%s\n' % (cfree)

	for arg in func.get_arguments():
		argtype = typeParse (arg.get_type())
		cfree = argtype.cfree('%s_ctype' % (arg.get_name()))
		if cfree != '':
			functiondef += '%s\n' % (cfree)
	
	if not func.skip_return():
		functiondef += 'return retval;\n'
	else:
		functiondef += 'return;\n'

	functiondef += '}\n'
	return functiondef 

def objectParse (obj):
	cppout = ''

	for item in obj.__dir__():
		if item.startswith('_'):
			continue
		if str(obj.__getattr__(item).__class__) == "<class 'gi.FunctionInfo'>":
			cppout += functionParse(obj.__getattr__(item))

	return cppout

if __name__ == '__main__':
	cpp = 'namespace GirCpp::%s {\n' % (importedgir._namespace)
	cpp += objectParse(importedgir);
	cpp += '}\n'
	print(cpp);
